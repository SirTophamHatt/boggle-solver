"use strict";
exports.__esModule = true;
/*
  A JavaScript implementation of a Trie search datastructure.

  Usage:

  trie = new Trie(dictionary-string);
  bool = trie.isWord(word);

  To use a packed (compressed) version of the trie stored as a string:

  compressed = trie.pack();
  ptrie = new PackedTrie(compressed);
  bool = ptrie.isWord(word)

*/
var ptrie = require("./ptrie");
var alphacode_1 = require("./alphacode");
var histogram_1 = require("./histogram");
var util_1 = require("./util");
var node_1 = require("./node");
var DEBUG = false;
// Create a Trie data structure for searching for membership of strings
// in a dictionary in a very space efficient way.
var Trie = (function () {
    function Trie(words) {
        this.root = new node_1.Node();
        this.lastWord = '';
        this.suffixes = {};
        this.cNext = 1;
        this.wordCount = 0;
        this.vCur = 0;
        this.insertWords(words);
    }
    // Insert words from one big string, or from an array.
    Trie.prototype.insertWords = function (words) {
        var i;
        if (words === undefined) {
            return;
        }
        if (typeof words === 'string') {
            words = words.split(/[^a-zA-Z]+/);
        }
        for (i = 0; i < words.length; i++) {
            words[i] = words[i].toLowerCase();
        }
        util_1.unique(words);
        for (i = 0; i < words.length; i++) {
            this.insert(words[i]);
        }
    };
    Trie.prototype.insert = function (word) {
        this._insert(word, this.root);
        var lastWord = this.lastWord;
        this.lastWord = word;
        var prefix = commonPrefix(word, lastWord);
        if (prefix === lastWord) {
            return;
        }
        var freeze = this.uniqueNode(lastWord, word, this.root);
        if (freeze) {
            this.combineSuffixNode(freeze);
        }
    };
    Trie.prototype._insert = function (word, node) {
        var i;
        var prefix;
        var next;
        var prop;
        // Duplicate word entry - ignore
        if (word.length === 0) {
            return;
        }
        // Do any existing props share a common prefix?
        for (prop in node) {
            if (!node.hasOwnProperty(prop)) {
                continue;
            }
            prefix = commonPrefix(word, prop);
            if (prefix.length === 0) {
                continue;
            }
            // Prop is a proper prefix - recurse to child node
            if (prop === prefix && node_1.Node.isNode(node.child(prop))) {
                this._insert(word.slice(prefix.length), node.child(prop));
                return;
            }
            // Duplicate terminal string - ignore
            if (prop === word && node.isTerminalString(prop)) {
                return;
            }
            next = new node_1.Node();
            next.setChild(prop.slice(prefix.length), node.child(prop));
            this.addTerminal(next, word = word.slice(prefix.length));
            node.deleteChild(prop);
            node.setChild(prefix, next);
            this.wordCount++;
            return;
        }
        // No shared prefix.  Enter the word here as a terminal string.
        this.addTerminal(node, word);
        this.wordCount++;
    };
    // Add a terminal string to node.
    // If 2 characters or less, just add with value === 1.
    // If more than 2 characters, point to shared node
    // Note - don't prematurely share suffixes - these
    // terminals may become split and joined with other
    // nodes in this part of the tree.
    Trie.prototype.addTerminal = function (node, prop) {
        if (prop.length <= 1) {
            node.setChild(prop, 1);
            return;
        }
        var next = new node_1.Node();
        node.setChild(prop[0], next);
        this.addTerminal(next, prop.slice(1));
    };
    Trie.prototype.optimize = function () {
        var scores = [];
        this.combineSuffixNode(this.root);
        this.prepDFS();
        this.countDegree(this.root);
        this.prepDFS();
        this.collapseChains(this.root);
    };
    // Convert Trie to a DAWG by sharing identical nodes
    Trie.prototype.combineSuffixNode = function (node) {
        // Frozen node - can't change.
        if (node._c) {
            return node;
        }
        // Make sure all children are combined and generate unique node
        // signature for this node.
        var sig = [];
        if (node.isTerminal()) {
            sig.push('!');
        }
        var props = node.props();
        for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            if (node_1.Node.isNode(node.child(prop))) {
                node.setChild(prop, this.combineSuffixNode(node.child(prop)));
                sig.push(prop);
                sig.push(node.child(prop)._c);
            }
            else {
                sig.push(prop);
            }
        }
        var sigString = sig.join('-');
        var shared = this.suffixes[sigString];
        if (shared) {
            return shared;
        }
        this.suffixes[sigString] = node;
        node._c = this.cNext++;
        return node;
    };
    Trie.prototype.prepDFS = function () {
        this.vCur++;
    };
    Trie.prototype.visited = function (node) {
        if (node._v === this.vCur) {
            return true;
        }
        node._v = this.vCur;
    };
    Trie.prototype.countDegree = function (node) {
        if (node._d === undefined) {
            node._d = 0;
        }
        node._d++;
        if (this.visited(node)) {
            return;
        }
        var props = node.props(true);
        for (var i = 0; i < props.length; i++) {
            this.countDegree(node.child(props[i]));
        }
    };
    // Remove intermediate singleton nodes by hoisting into their parent
    Trie.prototype.collapseChains = function (node) {
        var prop = '-invalid-';
        var props;
        var i;
        if (this.visited(node)) {
            return;
        }
        props = node.props();
        for (i = 0; i < props.length; i++) {
            prop = props[i];
            var child = node.child(prop);
            if (!node_1.Node.isNode(child)) {
                continue;
            }
            this.collapseChains(child);
            // Hoist the singleton child's single property to the parent
            if (child._g !== undefined && (child._d === 1 || child._g.length === 1)) {
                node.deleteChild(prop);
                prop += child._g;
                node.setChild(prop, child.child(child._g));
            }
        }
        // Identify singleton nodes
        if (props.length === 1 && !node.isTerminal()) {
            node._g = prop;
        }
    };
    Trie.prototype.isWord = function (word) {
        return this.isFragment(word, this.root);
    };
    Trie.prototype.isFragment = function (word, node) {
        if (word.length === 0) {
            return node.isTerminal();
        }
        if (node.child(word) === 1) {
            return true;
        }
        // Find a prefix of word reference to a child
        var props = node.props(true);
        for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            if (prop === word.slice(0, prop.length)) {
                return this.isFragment(word.slice(prop.length), node.child(prop));
            }
        }
        return false;
    };
    // Find highest node in Trie that is on the path to word
    // and that is NOT on the path to other.
    Trie.prototype.uniqueNode = function (word, other, node) {
        var props = node.props(true);
        for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            if (prop === word.slice(0, prop.length)) {
                if (prop !== other.slice(0, prop.length)) {
                    return node.child(prop);
                }
                return this.uniqueNode(word.slice(prop.length), other.slice(prop.length), node.child(prop));
            }
        }
        return undefined;
    };
    // Return packed representation of Trie as a string.
    //
    // Each node of the Trie is output on a single line.
    //
    // For example Trie("the them there thesis this"):
    // {
    //    "th": {
    //      "is": 1,
    //      "e": {
    //        "": 1,
    //        "m": 1,
    //        "re": 1,
    //        "sis": 1
    //      }
    //    }
    //  }
    //
    // Would be reperesented as:
    //
    // th0
    // e0is
    // !m,re,sis
    //
    // The line begins with a '!' iff it is a terminal node of the Trie.
    // For each string property in a node, the string is listed, along
    // with a (relative!) line number of the node that string references.
    // Terminal strings (those without child node references) are
    // separated by ',' characters.
    Trie.prototype.pack = function () {
        var self = this;
        var nodes = [];
        var nodeCount;
        var syms = {};
        var pos = 0;
        // Make sure we've combined all the common suffixes
        this.optimize();
        function nodeLine(node) {
            var line = '';
            var sep = '';
            if (node.isTerminal()) {
                line += ptrie.TERMINAL_PREFIX;
            }
            var props = node.props();
            for (var i = 0; i < props.length; i++) {
                var prop = props[i];
                if (node.isTerminalString(prop)) {
                    line += sep + prop;
                    sep = ptrie.STRING_SEP;
                    continue;
                }
                var child = node.child(prop);
                if (syms[child._n]) {
                    line += sep + prop + syms[child._n];
                    sep = '';
                    continue;
                }
                var ref = alphacode_1.toAlphaCode(node._n - child._n - 1 + symCount);
                // Large reference to smaller string suffix -> duplicate suffix
                if (child._g && ref.length >= child._g.length &&
                    node.isTerminalString(child._g)) {
                    ref = child._g;
                    line += sep + prop + ref;
                    sep = ptrie.STRING_SEP;
                    continue;
                }
                line += sep + prop + ref;
                sep = '';
            }
            return line;
        }
        // Topological sort into nodes array
        function numberNodes(node) {
            if (node._n !== undefined) {
                return;
            }
            var props = node.props(true);
            for (var i = 0; i < props.length; i++) {
                numberNodes(node.child(props[i]));
            }
            node._n = pos++;
            nodes.unshift(node);
        }
        var histAbs = new histogram_1.Histogram();
        var histRel = new histogram_1.Histogram();
        function analyzeRefs(node) {
            if (self.visited(node)) {
                return;
            }
            var props = node.props(true);
            for (var i = 0; i < props.length; i++) {
                var prop = props[i];
                var child = node.child(prop);
                var ref = node._n - child._n - 1;
                // Count the number of single-character relative refs
                if (ref < alphacode_1.BASE) {
                    histRel.add(ref);
                }
                // Count the number of characters saved by converting an absolute
                // reference to a one-character symbol.
                histAbs.add(child._n, alphacode_1.toAlphaCode(ref).length - 1);
                analyzeRefs(child);
            }
        }
        function symbolCount() {
            var topNodes = histAbs.highest(alphacode_1.BASE);
            var savings = [];
            savings[-1] = 0;
            var best = 0;
            var count = 0;
            var defSize = 3 + alphacode_1.toAlphaCode(nodeCount).length;
            for (var sym = 0; sym < alphacode_1.BASE; sym++) {
                if (topNodes[sym] === undefined) {
                    break;
                }
                // Cumulative savings of:
                //   saved characters in refs
                //   minus definition size
                //   minus relative size wrapping to 2 digits
                savings[sym] = topNodes[sym][1] - defSize -
                    histRel.countOf(alphacode_1.BASE - sym - 1) +
                    savings[sym - 1];
                log("savings[" + sym + "] " + savings[sym] + ' = ' +
                    savings[sym - 1] + ' +' +
                    topNodes[sym][1] + ' - ' + defSize + ' - ' +
                    histRel.countOf(alphacode_1.BASE - sym - 1) + ')');
                if (savings[sym] >= best) {
                    best = savings[sym];
                    count = sym + 1;
                }
            }
            return [count, topNodes];
        }
        numberNodes(this.root);
        nodeCount = nodes.length;
        this.prepDFS();
        analyzeRefs(this.root);
        var _a = symbolCount(), symCount = _a[0], topNodes = _a[1];
        var symDefs = [];
        for (var sym = 0; sym < symCount; sym++) {
            syms[topNodes[sym][0]] = alphacode_1.toAlphaCode(sym);
        }
        var nodeLines = [];
        for (var i = 0; i < nodeCount; i++) {
            nodeLines[i] = nodeLine(nodes[i]);
        }
        // Prepend symbols
        for (var sym = symCount - 1; sym >= 0; sym--) {
            nodeLines.unshift(alphacode_1.toAlphaCode(sym) + ':' +
                alphacode_1.toAlphaCode(nodeCount -
                    parseInt(topNodes[sym][0], 10) - 1));
        }
        return nodeLines.join(ptrie.NODE_SEP);
    };
    return Trie;
}());
exports.Trie = Trie;
function commonPrefix(w1, w2) {
    var i;
    var maxlen = Math.min(w1.length, w2.length);
    for (i = 0; i < maxlen && w1[i] === w2[i]; i++) { }
    return w1.slice(0, i);
}
function log(message) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    if (DEBUG) {
        console.log.apply(console, [message].concat(args));
    }
}
//# sourceMappingURL=trie.js.map