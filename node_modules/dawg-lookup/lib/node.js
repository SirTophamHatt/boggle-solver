"use strict";
exports.__esModule = true;
/*
  Node

  Each node contains some special properties (begining with '_'), as well as
  arbitrary string properties for string fragments contained in the input word
  dictionary.

  String properties can be "terminal" (have a numeric value of 1), or can
  referance another child Node.

  Note that a Node containing a terminal '' (empty string) property, is itself
  marked as a terminal Node (the prefix leading to this node is a word in the
  dictionary.
*/
var Node = (function () {
    function Node() {
        // Number of child properties.
        this._p = 0;
    }
    Node.prototype.child = function (prop) {
        return this[prop];
    };
    Node.prototype.setChild = function (prop, value) {
        var self = this;
        if (prop !== this._g) {
            // delete self._g;
        }
        if (self[prop] !== undefined) {
            this._p += 1;
        }
        if (this._p === 1) {
            // this._g = prop;
        }
        self[prop] = value;
    };
    Node.prototype.deleteChild = function (prop) {
        var self = this;
        if (prop === this._g) {
            // delete this._g;
        }
        this._p -= 1;
        delete self[prop];
        if (this._p === 1) {
            // this._g = this.props()[0];
        }
    };
    // A property is a terminal string
    Node.prototype.isTerminalString = function (prop) {
        return typeof this.child(prop) === 'number';
    };
    // This node is a terminal node (the prefix string is a word in the
    // dictionary).
    Node.prototype.isTerminal = function () {
        return this.isTerminalString('');
    };
    // Well ordered list of properties in a node (string or object properties)
    // Use nodesOnly === true to return only properties of child nodes (not
    // terminal strings).
    Node.prototype.props = function (nodesOnly) {
        var me = this;
        var props = [];
        for (var prop in me) {
            if (!me.hasOwnProperty(prop)) {
                continue;
            }
            if (prop !== '' && prop[0] !== '_') {
                if (!nodesOnly || Node.isNode(this.child(prop))) {
                    props.push(prop);
                }
            }
        }
        props.sort();
        return props;
    };
    // Compute in-degree of all nodes and mark the
    // singleton nodes.
    Node.countDegree = function (root) {
        var walker = new Walker(root);
        walker.dfs(function (order, node) {
            if (order === 'post') {
                return;
            }
            if (node._d === undefined) {
                node._d = 0;
            }
            node._d++;
        });
    };
    // Node has just a single (non-special) property.
    Node.prototype.isSingleton = function () {
        return this._p === 1 && !this.isTerminal();
    };
    // This function can be used as a Type Guard (TypeScript)
    Node.isNode = function (n) {
        return n instanceof Node;
    };
    return Node;
}());
exports.Node = Node;
var Walker = (function () {
    function Walker(root) {
        this.root = root;
        this.visitMap = new Map();
    }
    Walker.prototype.reset = function () {
        this.visitMap = new Map();
        return this;
    };
    Walker.prototype.visit = function (node) {
        this.visitMap.set(node, true);
    };
    Walker.prototype.visited = function (node) {
        return this.visitMap.get(node) || false;
    };
    Walker.prototype.dfs = function (handler) {
        this.reset();
        this._dfs(this.root, null, '', handler);
    };
    // Depth-first search via callback handler.
    Walker.prototype._dfs = function (node, parent, propParent, handler) {
        // The handler can be called multiple times from different parents
        // since Nodes can form a multi-graph.
        handler('pre', node, parent, propParent);
        if (this.visited(node)) {
            return;
        }
        this.visit(node);
        var props = node.props(true);
        for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
            var prop = props_1[_i];
            this._dfs(node.child(prop), node, prop, handler);
        }
        handler('post', node, parent, propParent);
    };
    return Walker;
}());
exports.Walker = Walker;
//# sourceMappingURL=node.js.map