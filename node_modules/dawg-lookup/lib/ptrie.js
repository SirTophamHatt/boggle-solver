"use strict";
exports.__esModule = true;
var alphacode_1 = require("./alphacode");
exports.NODE_SEP = ';';
exports.STRING_SEP = ',';
exports.TERMINAL_PREFIX = '!';
exports.MIN_LETTER = 'a';
exports.MAX_LETTER = 'z';
exports.MAX_WORD = new Array(10).join(exports.MAX_LETTER);
var reNodePart = new RegExp('([' + exports.MIN_LETTER + '-' + exports.MAX_LETTER +
    ']+)(' + exports.STRING_SEP + '|[0-9A-Z]+|$)', 'g');
var reSymbol = new RegExp("([0-9A-Z]+):([0-9A-Z]+)");
/*
 * Packed Trie structure.
 *
 * This class can read in a packed Trie (actually DAWG) in the form
 * of a string encoding of a set of nodes.  It will then spilt it
 * into an array of strings, and use the resulting array to
 * resolve dictionary membership.
 *
 * Usage:
 *
 *   // Unpack a packed dictionary string for use.
 *   var ptrie = new PTrie(packedString);
 *
 *   // Test a word for membership in the dictionary.
 *   if (ptrie.isWord(myWord)) {
 *     ...
 *   }
 *
 *   // For command completion - find first 20 words that begin with a prefix.
 *   var words = ptrie.completions(prefix, 20);
 */
var PTrie = (function () {
    function PTrie(packed) {
        this.syms = [];
        this.nodes = packed.split(exports.NODE_SEP);
        this.syms = [];
        this.symCount = 0;
        while (true) {
            var m = reSymbol.exec(this.nodes[this.symCount]);
            if (!m) {
                break;
            }
            if (alphacode_1.fromAlphaCode(m[1]) !== this.symCount) {
                throw new Error("Invalid Symbol name - found " + m[1] +
                    " when expecting " + alphacode_1.toAlphaCode(this.symCount));
            }
            this.syms[this.symCount] = alphacode_1.fromAlphaCode(m[2]);
            this.symCount++;
        }
        this.nodes.splice(0, this.symCount);
    }
    // Is word in the dictionary (exact match).
    PTrie.prototype.isWord = function (word) {
        if (word === '') {
            return false;
        }
        return this.match(word) === word;
    };
    // Returns the longest match that is prefix of word.
    PTrie.prototype.match = function (word) {
        var matches = this.matches(word);
        if (matches.length === 0) {
            return '';
        }
        return matches[matches.length - 1];
    };
    // Return all entries that match a prefix of word (in order of increasing
    // length.
    PTrie.prototype.matches = function (word) {
        return this.words(word, word + exports.MIN_LETTER);
    };
    // Return all entries that begin with a prefix.
    PTrie.prototype.completions = function (prefix, limit) {
        return this.words(prefix, beyond(prefix), limit);
    };
    PTrie.prototype.words = function (from, beyond, limit) {
        var words = [];
        function catchWords(word, ctx) {
            if (limit !== undefined && words.length >= limit) {
                ctx.abort = true;
                return;
            }
            words.push(word);
        }
        this.enumerate(0, '', { from: from,
            beyond: beyond,
            fn: catchWords,
            prefixes: (from + exports.MIN_LETTER) === beyond
        });
        return words;
    };
    PTrie.prototype.enumerate = function (inode, prefix, ctx) {
        var _this = this;
        var node = this.nodes[inode];
        var cont = true;
        function emit(word) {
            if (ctx.prefixes) {
                if (word === ctx.from.slice(0, word.length)) {
                    ctx.fn(word, ctx);
                }
                return;
            }
            if (ctx.from <= word && word < ctx.beyond) {
                ctx.fn(word, ctx);
            }
        }
        if (node[0] === exports.TERMINAL_PREFIX) {
            emit(prefix);
            if (ctx.abort) {
                return;
            }
            node = node.slice(1);
        }
        node.replace(reNodePart, function (w, str, ref) {
            var match = prefix + str;
            // Done or no possible future match from str
            if (ctx.abort ||
                match >= ctx.beyond ||
                match < ctx.from.slice(0, match.length)) {
                return '';
            }
            var isTerminal = ref === exports.STRING_SEP || ref === '';
            if (isTerminal) {
                emit(match);
                return '';
            }
            _this.enumerate(_this.inodeFromRef(ref, inode), match, ctx);
            return '';
        });
    };
    // References are either absolute (symbol) or relative (1 based).
    PTrie.prototype.inodeFromRef = function (ref, inodeFrom) {
        var dnode = alphacode_1.fromAlphaCode(ref);
        if (dnode < this.symCount) {
            return this.syms[dnode];
        }
        dnode -= this.symCount;
        return inodeFrom + dnode + 1;
    };
    return PTrie;
}());
exports.PTrie = PTrie;
// Return a string that is the smallest string greater than
// any string which is prefixed with s.
function beyond(s) {
    if (s.length === 0) {
        return exports.MAX_WORD;
    }
    var code = s.charCodeAt(s.length - 1);
    return s.slice(0, -1) + String.fromCharCode(code + 1);
}
//# sourceMappingURL=ptrie.js.map